---
/**
 * Blog Post Template
 * Dynamic routing for individual blog posts
 */

import { getCollection } from 'astro:content';
import type { CollectionEntry } from 'astro:content';
import BaseLayout from '../../layouts/BaseLayout.astro';
import AuthorBio from '../../components/blog/AuthorBio.astro';
import RelatedPosts from '../../components/blog/RelatedPosts.astro';
import SocialShare from '../../components/blog/SocialShare.astro';
import TableOfContents from '../../components/blog/TableOfContents.astro';
import SubredditCTA from '../../components/SubredditCTA.astro';
import AffiliateBlock from '../../components/AffiliateBlock.astro';
import { generateArticleSchema, generateBreadcrumbSchema, generateFAQSchema, generateHowToSchema, generateVideoSchema } from '../../utils/schema';
import { generateBlogPostTitle, generateBlogKeywords } from '../../utils/seo';


export const prerender = true;

export async function getStaticPaths() {
  const blogEntries = await getCollection('blog');
  return blogEntries.map((entry) => ({
    params: { slug: entry.slug },
    props: { entry },
  }));
}

interface Props {
  entry: CollectionEntry<'blog'>;
}

const { entry } = Astro.props;
const { Content, headings } = await entry.render();

// Extract FAQs from markdown content for FAQ schema
function extractFAQs(content: string): Array<{ question: string; answer: string }> {
  const faqs: Array<{ question: string; answer: string }> = [];

  // IMPROVED: Accept more heading variations for FAQ sections
  // Matches: FAQ, FAQs, Frequently Asked Questions, Common Questions, Q&A
  // [^\n]* ensures the keyword is on the actual H2 heading line, not in content after it
  const faqSectionMatch = content.match(/##\s+[^\n]*(FAQs?|Frequently Asked Questions?|Common Questions?|Q&?A)\b[^\n]*\n([\s\S]+?)(?=\n##\s|$)/i);
  if (!faqSectionMatch) return faqs;

  const faqSection = faqSectionMatch[2];

  // Extract each FAQ (H3 questions followed by answers until next H3 or end)
  const faqPattern = /###\s+(.+?)\n+([\s\S]+?)(?=\n###|$)/g;
  let match;

  while ((match = faqPattern.exec(faqSection)) !== null) {
    const question = match[1].trim();
    let answer = match[2]
      .trim()
      .replace(/\n\n+/g, ' ') // Replace multiple newlines with space
      .replace(/\*\*/g, '') // Remove bold markdown
      .replace(/\*/g, '') // Remove italic markdown
      .replace(/\[([^\]]+)\]\([^\)]+\)/g, '$1') // Remove links, keep text
      .replace(/\s+/g, ' '); // Normalize whitespace

    // IMPROVED: Smart truncation - end at sentence boundaries
    if (answer.length > 500) {
      const truncated = answer.substring(0, 500);
      const lastPeriod = truncated.lastIndexOf('.');
      const lastQuestion = truncated.lastIndexOf('?');
      const lastExclamation = truncated.lastIndexOf('!');
      const cutPoint = Math.max(lastPeriod, lastQuestion, lastExclamation);

      // Only cut at sentence if we found one after 300 chars (keep reasonable length)
      if (cutPoint > 300) {
        answer = answer.substring(0, cutPoint + 1);
      } else {
        answer = truncated + '...';
      }
    }

    faqs.push({ question, answer });
  }

  return faqs;
}

// IMPROVED: Extract HowTo steps with more flexible patterns
function extractHowToSteps(content: string, title: string): { steps: Array<{ name: string; text: string }>; howToTitle: string; description: string } | null {
  const steps: Array<{ name: string; text: string }> = [];

  // Pattern 1: Individual "### Step N:" headings
  const stepHeadingPattern = /###\s+Step\s+\d+[:\.]?\s+(.+?)\n+([\s\S]+?)(?=\n###|$)/g;
  let match;
  while ((match = stepHeadingPattern.exec(content)) !== null) {
    steps.push({
      name: match[1].trim(),
      text: match[2].trim().replace(/\*\*/g, '').replace(/\*/g, '').replace(/\n\n/g, ' ')
    });
  }

  // Pattern 2: Numbered lists ONLY in "how to" posts or sections with step headings
  if (steps.length === 0) {
    // Only look for numbered lists if title indicates "how to" content
    const isHowToPost = /how to|guide to|complete guide|getting started|step-by-step/i.test(title);

    if (isHowToPost) {
      // Look for numbered lists within sections that have "how to" or "steps" in the heading
      const howToSectionPattern = /##[^\n]*(how to|steps|getting started|process)[^\n]*\n([\s\S]+?)(?=\n##\s|$)/gi;
      let sectionMatch;

      while ((sectionMatch = howToSectionPattern.exec(content)) !== null) {
        const sectionContent = sectionMatch[2];
        const numberedListPattern = /\d+\.\s+(.+?)(?:\n|$)/g;
        const matches = sectionContent.match(numberedListPattern);

        if (matches && matches.length >= 3) {
          matches.slice(0, 10).forEach((line, idx) => {
            const text = line.replace(/^\d+\.\s+/, '').replace(/\*\*/g, '').trim();
            if (text.length > 10) {
              steps.push({
                name: `Step ${idx + 1}`,
                text: text
              });
            }
          });
          break; // Only use first matching section
        }
      }
    }
  }

  if (steps.length >= 3) {
    return {
      steps: steps.slice(0, 10),
      howToTitle: title.replace(/^(How to|Complete Guide to|Guide to)\s+/i, ''),
      description: `Step-by-step guide to ${title.toLowerCase()}`
    };
  }

  return null;
}

// NEW: Detect markdown tables for Table schema
function detectTables(content: string): boolean {
  // Markdown tables have format:
  // | Header 1 | Header 2 |
  // |----------|----------|
  // | Data 1   | Data 2   |
  const tablePattern = /\|.+\|[\r\n]+\|[-:\s|]+\|[\r\n]+(\|.+\|[\r\n]+)+/g;
  return tablePattern.test(content);
}

// NEW: Extract YouTube videos for VideoObject schema
function extractVideos(content: string): Array<{ videoId: string; url: string }> {
  const videos: Array<{ videoId: string; url: string }> = [];

  // Match YouTube URLs (watch?v= and youtu.be formats)
  const youtubePattern = /(?:youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]{11})/g;
  let match;

  while ((match = youtubePattern.exec(content)) !== null) {
    const videoId = match[1];
    videos.push({
      videoId,
      url: `https://www.youtube.com/watch?v=${videoId}`
    });
  }

  return videos;
}

// Get raw markdown content from entry
const rawContent = entry.body;

// Extract schemas with debug logging
const extractedFAQs = extractFAQs(rawContent);
const extractedHowTo = extractHowToSteps(rawContent, entry.data.title);
const hasTables = detectTables(rawContent);
const extractedVideos = extractVideos(rawContent);

// Debug logging (visible during build)
console.log(`[SCHEMA] ${entry.slug}:`);
console.log(`  - FAQs: ${extractedFAQs.length} found`);
console.log(`  - HowTo steps: ${extractedHowTo ? extractedHowTo.steps.length : 0} found`);
console.log(`  - Tables: ${hasTables ? 'YES' : 'NO'}`);
console.log(`  - Videos: ${extractedVideos.length} found`);

// Get related posts from same category
const allPosts = await getCollection('blog');
const relatedPosts = allPosts.filter(
  (post) => post.data.category === entry.data.category && post.slug !== entry.slug
);

// SEO setup
const pageUrl = `https://www.indoorclimbinggym.com/blog/${entry.slug}/`;
const title = generateBlogPostTitle(entry.data.title);
const keywords = generateBlogKeywords(entry.data.tags, entry.data.category);

// Use canonical URL from frontmatter if provided, otherwise use page URL
const canonicalUrl = entry.data.canonicalURL || pageUrl;

// Format dates for schema
const publishedDate = entry.data.publishedDate.toISOString();
const updatedDate = (entry.data.updatedDate || entry.data.publishedDate).toISOString();

// Generate schemas
const articleSchema = generateArticleSchema(
  {
    title: entry.data.title,
    description: entry.data.description,
    author: entry.data.author,
    publishedDate,
    updatedDate,
    heroImage: entry.data.heroImage,
    heroImageAlt: entry.data.heroImageAlt,
    category: entry.data.category,
    wordCount: entry.data.wordCount,
    tags: entry.data.tags,
  },
  pageUrl
);

const breadcrumbs = [
  { label: 'Home', url: 'https://www.indoorclimbinggym.com' },
  { label: 'Guides', url: 'https://www.indoorclimbinggym.com/blog' },
  {
    label: entry.data.category.charAt(0).toUpperCase() + entry.data.category.slice(1),
    url: `https://www.indoorclimbinggym.com/blog/${entry.data.category}`,
  },
  { label: entry.data.title, url: pageUrl },
];

const breadcrumbSchema = generateBreadcrumbSchema(breadcrumbs);

// Generate FAQ schema if FAQs were found
const faqSchema = extractedFAQs.length > 0 ? generateFAQSchema(extractedFAQs) : null;

// Generate HowTo schema if step-by-step content was found
const howToSchema = extractedHowTo
  ? generateHowToSchema(extractedHowTo.howToTitle, extractedHowTo.description, extractedHowTo.steps)
  : null;

// Generate Video schemas if YouTube videos were found
const videoSchemas = extractedVideos.map(video =>
  generateVideoSchema(video.videoId, entry.data.title, entry.data.description)
);

// CONDITIONAL SCHEMA COMBINING - Only include schemas for content that exists!
const schemas = [
  articleSchema,
  breadcrumbSchema,
  ...(faqSchema ? [faqSchema] : []),
  ...(howToSchema ? [howToSchema] : []),
  ...videoSchemas  // Only included if videos detected
  // NOTE: Table schema intentionally NOT included - handled by browser rendering
];

// Format published date
const formattedDate = entry.data.publishedDate.toLocaleDateString('en-US', {
  year: 'numeric',
  month: 'long',
  day: 'numeric',
});

// Category colors
const categoryColors: { [key: string]: string } = {
  guides: 'bg-blue-100 text-blue-800',
  tips: 'bg-green-100 text-green-800',
  reviews: 'bg-purple-100 text-purple-800',
  industry: 'bg-orange-100 text-orange-800',
  gear: 'bg-red-100 text-red-800',
};
const categoryColor = categoryColors[entry.data.category] || 'bg-gray-100 text-gray-800';
---

<BaseLayout
  title={title}
  description={entry.data.description}
  canonical={canonicalUrl}
  ogImage={entry.data.heroImage}
  ogType="article"
  keywords={keywords}
  schema={schemas}
  breadcrumbs={breadcrumbs}
  articlePublishedTime={publishedDate}
  articleModifiedTime={updatedDate}
  articleAuthor={entry.data.author}
  articleSection={entry.data.category}
  articleTags={entry.data.tags}
>
  <!-- Article Header -->
  <article class="max-w-4xl mx-auto">
    <!-- Breadcrumb Navigation -->
    <nav class="text-sm text-gray-600 mb-6" aria-label="Breadcrumb">
      <ol class="flex flex-wrap items-center gap-2">
        <li><a href="/" class="hover:text-sage">Home</a></li>
        <li>/</li>
        <li><a href="/blog/" class="hover:text-sage">Guides</a></li>
        <li>/</li>
        <li>
          <a href={`/blog/${entry.data.category}/`} class="hover:text-sage">
            {entry.data.category.charAt(0).toUpperCase() + entry.data.category.slice(1)}
          </a>
        </li>
      </ol>
    </nav>

    <!-- Category & Reading Time -->
    <div class="flex items-center gap-3 mb-4">
      <span class={`text-sm font-semibold px-3 py-1 rounded-full ${categoryColor}`}>
        {entry.data.category.charAt(0).toUpperCase() + entry.data.category.slice(1)}
      </span>
      {entry.data.readingTime && (
        <span class="text-sm text-gray-500">{entry.data.readingTime} min read</span>
      )}
    </div>

    <!-- Title -->
    <h1 class="text-4xl md:text-5xl font-bold text-granite mb-4 leading-tight">
      {entry.data.title}
    </h1>

    <!-- Meta Info -->
    <div class="flex items-center gap-4 text-gray-600 mb-8">
      <span class="font-medium">{entry.data.author}</span>
      <span>•</span>
      <time datetime={entry.data.publishedDate.toISOString()}>{formattedDate}</time>
      {entry.data.updatedDate && (
        <>
          <span>•</span>
          <span class="text-sm">
            Updated{' '}
            {entry.data.updatedDate.toLocaleDateString('en-US', {
              year: 'numeric',
              month: 'short',
              day: 'numeric',
            })}
          </span>
        </>
      )}
    </div>

    <!-- Hero Image -->
    <div class="aspect-video w-full overflow-hidden rounded-lg mb-8">
      <img
        src={entry.data.heroImage}
        alt={entry.data.heroImageAlt}
        class="w-full h-full object-cover"
      />
    </div>

    <!-- Table of Contents -->
    <TableOfContents headings={headings} />

    <!-- Article Content -->
    <div class="prose prose-lg max-w-none mb-8">
      <Content />
    </div>

    <!-- Affiliate Block -->
    <AffiliateBlock 
      title="Recommended Gear" 
      subtitle="Our top picks for climbers."
      count={3}
    />

    <!-- Tags -->
    {entry.data.tags.length > 0 && (
      <div class="flex flex-wrap gap-2 mb-8">
        {entry.data.tags.map((tag) => (
          <span class="text-sm bg-gray-100 text-gray-700 px-3 py-1 rounded-full">#{tag}</span>
        ))}
      </div>
    )}

    <!-- Social Share -->
    <SocialShare title={entry.data.title} url={pageUrl} />

    <!-- Author Bio -->
    <AuthorBio
      author={entry.data.author}
      avatar={entry.data.authorAvatar}
      bio={entry.data.authorBio}
    />

    <!-- Subreddit CTA -->
    <div class="my-12">
      <SubredditCTA variant="blog" />
    </div>

    <!-- Related Posts -->
    <RelatedPosts posts={relatedPosts} currentSlug={entry.slug} />
  </article>
</BaseLayout>

<style is:global>
  /* Prose styling for markdown content */
  .prose {
    color: #555;
  }

  .prose h2 {
    font-size: 2rem;
    font-weight: bold;
    margin-top: 2.5rem;
    margin-bottom: 1rem;
    color: #555;
    scroll-margin-top: 100px;
  }

  .prose h3 {
    font-size: 1.5rem;
    font-weight: bold;
    margin-top: 2rem;
    margin-bottom: 0.75rem;
    color: #555;
    scroll-margin-top: 100px;
  }

  .prose p {
    margin-bottom: 1.25rem;
    line-height: 1.75;
  }

  .prose a {
    color: #98a48b;
    text-decoration: underline;
  }

  .prose a:hover {
    color: #7a8670;
  }

  .prose ul,
  .prose ol {
    margin-bottom: 1.25rem;
    padding-left: 1.5rem;
  }

  .prose li {
    margin-bottom: 0.5rem;
  }

  .prose img {
    border-radius: 0.5rem;
    margin: 2rem 0;
  }

  .prose blockquote {
    border-left: 4px solid #98a48b;
    padding-left: 1rem;
    font-style: italic;
    color: #666;
    margin: 2rem 0;
  }

  .prose code {
    background-color: #f4f4f4;
    padding: 0.25rem 0.5rem;
    border-radius: 0.25rem;
    font-size: 0.9em;
  }

  .prose pre {
    background-color: #2d2d2d;
    color: #f8f8f2;
    padding: 1rem;
    border-radius: 0.5rem;
    overflow-x: auto;
    margin: 1.5rem 0;
  }

  .prose pre code {
    background-color: transparent;
    padding: 0;
    color: inherit;
  }

  .prose table {
    width: 100%;
    border-collapse: collapse;
    margin: 2rem 0;
  }

  .prose th,
  .prose td {
    border: 1px solid #ddd;
    padding: 0.75rem;
    text-align: left;
  }

  .prose th {
    background-color: #f8f8f5;
    font-weight: bold;
  }



  /* Mobile responsive table wrapper */
  .table-wrapper {
    overflow-x: auto;
    -webkit-overflow-scrolling: touch; /* Smooth scrolling on iOS */
    margin: 2rem 0;
    border-radius: 0.5rem;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    position: relative;
  }

  /* Remove margin from table when wrapped */
  .table-wrapper table {
    margin: 0;
  }

  /* Scrollbar styling for better UX */
  .table-wrapper::-webkit-scrollbar {
    height: 8px;
  }

  .table-wrapper::-webkit-scrollbar-track {
    background: #f1f1f1;
    border-radius: 4px;
  }

  .table-wrapper::-webkit-scrollbar-thumb {
    background: #98a48b;
    border-radius: 4px;
  }

  .table-wrapper::-webkit-scrollbar-thumb:hover {
    background: #7a8670;
  }

  /* Visual indicator for scrollable content */
  @media (max-width: 768px) {
    .table-wrapper::after {
      content: '→ Scroll';
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      background: rgba(152, 164, 139, 0.9);
      color: white;
      padding: 0.25rem 0.5rem;
      border-radius: 0.25rem;
      font-size: 0.75rem;
      font-weight: 600;
      pointer-events: none;
      opacity: 0;
      animation: fadeInOut 3s ease-in-out;
    }

    @keyframes fadeInOut {
      0%, 100% { opacity: 0; }
      10%, 90% { opacity: 1; }
    }

    /* Smaller text and padding on mobile for better fit */
    .prose table {
      font-size: 0.875rem;
    }

    .prose th,
    .prose td {
      padding: 0.5rem;
    }
  }
</style>

<script>
  // Wrap all tables in a scrollable container for mobile responsiveness
  document.addEventListener('DOMContentLoaded', () => {
    const tables = document.querySelectorAll('.prose table');

    tables.forEach((table) => {
      // Skip if already wrapped
      if (table.parentElement?.classList.contains('table-wrapper')) {
        return;
      }

      // Create wrapper
      const wrapper = document.createElement('div');
      wrapper.className = 'table-wrapper';

      // Wrap the table
      table.parentNode?.insertBefore(wrapper, table);
      wrapper.appendChild(table);
    });
  });
</script>
